#chin.py
import sys
import os

# Class that holds information for every bytespan
class ByteSpan:
	def __init__(self, start, end, corefId):
		self.start = start
		self.end = end
		self.corefId = corefId
	
	# For debugging
	def printargs(self):
		print self.start, self.end, self.corefId
	
	def getStart(self):
		return self.start

	def getEnd(self):
		return self.end

	def getCorefId(self):
		return self.corefId

# Generates a span tag with an id specified in the formal params.
# 	Each bytespan object has covers a span of bytes. For example, the
# 	bytespan 0,12 covers the bytes from 0 - 12. Each of these objects
# 	is associated with a coref chain, indicated by the coref ID. The
# 	intended use of this function is to generate a span tag whose id
# 	is the same as the bytespan object's coref ID.
def generateTagOpen(id):
	return "<span class=\"" + str(id) + "\">"

# Generates a closing for a span tag.
# 	Intended to be close a tag that was openend with generateTagOpen()
def generateTagClose():
	return "</span>"

def generateJs():
	print "this is a stub for later"

# The ordering function that helps sort() sort the bss objects. It first
# 	looks at initial position, indicated by bss[anything].getStart(); if
# 	one of them starts first, that one should come before the other in
# 	the list. If they tie, the one that has the longest bytespan comes
# 	first.
def orderBss(x, y):
	if y.getStart() != x.getStart():
		return x.getStart() - y.getStart()
	else:
		return (y.getEnd() - y.getStart()) - (x.getEnd() - x.getStart())

def updateGraph(pos, updateAmt):
	for placeholder in range(pos, len(graph)):
		graph[placeholder] += updateAmt



# Open file from argument
raw = open(sys.argv[1], 'r')

# Create a list of all lines in the key
lines = raw.readlines()

# Create a list to hold the ByteSpan objects
bss = list()

# Process each line in succession
# 	Parse bytespan and corefid, put in object, place object in list
for line in range(1, len(lines)):
	words = lines[line].split()
	byteRange = words[1].split(",")	#parse bytespan
	id = filter(lambda x: x in '1234567890', words[5])	#turn bytespan into numbers
	bs = ByteSpan(int(byteRange[0]), int(byteRange[1]), int(id))	#store bytespan in object
	bss.append(bs)	#add object to list

# Sort the list. Begin with starting position of bytespan; in the
# 	event of a tie, the largest bytespan comes first.
bss = sorted(bss, cmp=orderBss)
#for i in bss:
	#i.printargs()

# Create graph that tells how much the offset is at any given point in the file.
# 	Adding the <span> tags to the HTML file changes how many bytes into the file
# 	a word is; This graph is used to tell how many bytes the offset at any point
# 	in the file is.
graph = list()
fileSize = os.path.getsize(sys.argv[2])
for i in range(0, fileSize):
	graph.append(0)

# Open new html file, begin writing basic template data to it.
write = open("corefoverlay.html", 'w')
read = open(sys.argv[2], 'rb')
start = "<html><head></head>\n<body>\n"
print start
write.write(start)

# Update offset graph
updateGraph(0, len(start))



index = 0
# Handle everything that happens before the first bytespan
while index < bss[0].getStart():
	c = read.read(1)
	print c
	index+=1

# Process 1 bytespan object:
# 	1. Seek to the byte in the overlay file that's delineated by [item].getStart()
# 		Because we are adding tags, the location of the byte in the original file will
# 		not correspond directly to the byte in the overlay file; to get the corresponding
# 		byte, we must include the "offset" generated by the tags, which is stored in
# 		the list called "graph". So the location of any byte in the overlay file can
# 		be expressed as overlayPos = originalPos + graph[x], where the integer at graph[x]
# 		contains the offset at the point x.
# 	2. Copy everything from the position we will be inserting to until the end of the
# 		overlay file into a buffer. This may sound expensive, but remember that the
# 		bytespan objects are sorted, so the cost of this is actually usually only a few
# 		characters.
# 	3. Insert opening tag that will hold the NP in the given bytespan
# 	4. Update the graph that keeps track of offset
# 	5. Write content of tag
# 	6. Insert closing tag
# 	7. Update graph that keeps track of offset
# 	8. Copy back the buffer
bssItem = 0
while bssItem < 1:
	tag = generateTagOpen(bss[0].getCorefId()) # 3
	print tag
	updateGraph(bss[0].getStart(), len(generateTagOpen(bss[0].getCorefId()))) # 4
	while index < bss[0].getEnd(): # 5
		c = read.read(1)
		print c
		index+=1
	tag = generateTagClose() # 6
	print tag
	updateGraph(bss[0].getEnd(), len(generateTagClose())) # 7

	bssItem+=1
